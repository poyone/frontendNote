# Why Zustand

Zustand主要是为了解决React Context 在状态更新时会导致所有消费该 Context 的组件重新渲染，即使这些组件只依赖于 Context 中很小一部分（甚至没有依赖）发生变化的状态。 这就是所谓的“不必要的 re-render”问题。

# 是否所有状态都需要用 Zustand？

React 自带的 useState, useReducer 以及组件 Props 传递对于管理状态来说，在绝大多数场景下都是首选且完全足够的方案。Zustand 是用来解决特定问题的工具，而不是 React 状态管理的唯一方式。

# 应该在什么情况下考虑使用 Zustand (或类似库)

1. **全局状态 (Global State)：** 需要在应用中许多分散的、无直接父子关系的组件中访问和修改的状态。例如：
    - 用户身份信息 (认证状态、用户资料)
    - 应用主题 (深色/浅色模式)
    - 全局通知/提示信息
    - 购物车状态 (在电商应用中遍布各处)
    - 需要在路由切换后保持的状态

2. **避免深层次 Props Drilling：** 当需要将状态传递给深层嵌套的组件时，一层层传递 Props 会变得非常繁琐且难以维护（“Prop Drilling Hell”）。Context 可以解决传递问题，但如前面所述，它存在不必要的渲染问题。Zustand 允许深层组件直接按需订阅所需状态，跳过多层传递。

3. **高频更新状态且影响范围广：** 当某个状态会频繁更新（如实时数据、拖拽位置、复杂动画状态），并且这个状态被许多组件订阅时，使用 Zustand 的细粒度订阅可以显著优化性能，避免 Context 更新造成的渲染海啸。

4. **需要状态持久化、中间件、DevTools 等高级功能：** Zustand 提供了开箱即用或易于集成的支持：
    - **持久化 (Persist)：** 自动将状态保存到 `localStorage`/`sessionStorage` 或其他地方，刷新页面不丢失。
    - **中间件 (Middleware)：** 方便地添加日志记录、异步操作管理、状态变更跟踪、Immer 集成（简化不可变更新）等。
    - **Redux DevTools 集成：** 方便地使用强大的 Redux DevTools 进行状态调试和时间旅行。

5. **更清晰的状态逻辑组织：** 对于非常复杂的业务逻辑状态，将其抽离到 Zustand store 中，可以使组件更专注于渲染，逻辑更集中、更易于测试。

